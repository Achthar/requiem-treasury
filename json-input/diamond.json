{
  "language": "Solidity",
  "sources": {
    "contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {    \n\n    constructor(address _contractOwner, address _diamondCutFacet) payable {        \n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet, \n            action: IDiamondCut.FacetCutAction.Add, \n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");        \n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/upgradeInitializers/TreasuryInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibStorage, WithStorage, TreasuryStorage, ManagementStorage, QueueStorage} from \"../libraries/LibStorage.sol\";\n\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {IERC173} from \"../interfaces/IERC173.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {IManagement} from \"../interfaces/IManagement.sol\";\nimport {IREQ} from \"../interfaces/IREQ.sol\";\nimport {ICreditREQ} from \"../interfaces/ICreditREQ.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract TreasuryInit is WithStorage {\n    // You can add parameters to this function in order to pass in\n    // data to set your own state variables\n    function init(\n        address _management,\n        address _req,\n        address _creq\n    ) external {\n        // adding ERC165 data\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // add your own state variables\n        // EIP-2535 specifies that the `diamondCut` function takes two optional\n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface\n\n        TreasuryStorage storage ts = LibStorage.treasuryStorage();\n        require(_req != address(0), \"Zero address: REQ\");\n        ts.REQ = IREQ(_req);\n        ts.timelockEnabled = true;\n        ts.timeNeededForQueue = 0;\n        ts.useExcessReserves = false;\n        ts.CREQ = ICreditREQ(_creq);\n\n        QueueStorage storage qs = LibStorage.queueStorage();\n        qs.currentIndex = 0;\n\n        ManagementStorage storage ms = LibStorage.managementStorage();\n        ms.governor = _management;\n        ms.guardian = _management;\n        ms.policy = _management;\n        ms.vault = _management;\n    }\n}\n"
    },
    "contracts/libraries/LibStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.15;\n\nimport \"../interfaces/IREQ.sol\";\nimport \"../interfaces/ICreditREQ.sol\";\nimport \"./LibDiamond.sol\";\n\n// We do not use an array of stucts to avoid pointer conflicts\n// Mappings help us avoid out of bound issues as in arrays,\n// particularly if another mapping is added to the struct\nstruct QueueStorage {\n    uint256 currentIndex;\n    mapping(uint256 => uint256) managing;\n    mapping(uint256 => address) toPermit;\n    mapping(uint256 => address) pricer;\n    mapping(uint256 => address) quote;\n    mapping(uint256 => uint256) timelockEnd;\n    mapping(uint256 => bool) nullify;\n    mapping(uint256 => bool) executed;\n}\n\n\n// Management storage that stores the different DAO roles\nstruct ManagementStorage {\n    address governor;\n    address guardian;\n    address policy;\n    address vault;\n    address newGovernor;\n    address newGuardian;\n    address newPolicy;\n    address newVault;\n}\n\n// The core Treasury store\nstruct TreasuryStorage {\n    // requiem global assets\n    IREQ REQ;\n    ICreditREQ CREQ;\n    // general registers\n    mapping(uint256 => address[]) registry;\n    mapping(uint256 => mapping(address => bool)) permissions;\n    // pricer and corresponding quote address\n    mapping(address => address) assetPricer;\n    mapping(address => address) quotes;\n    mapping(address => uint256) debtLimits;\n    // asset data\n    mapping(address => uint256) assetReserves;\n    mapping(address => uint256) assetDebt;\n    // aggregted data\n    uint256 totalReserves;\n    uint256 totalDebt;\n    uint256 reqDebt;\n    \n    uint256 timeNeededForQueue;\n    bool timelockEnabled;\n    bool useExcessReserves;\n    uint256 onChainGovernanceTimelock;\n}\n\n/**\n * All of Requiems's treasury storage is stored in a single TreasuryStorage struct.\n *\n * The Diamond Storage pattern (https://dev.to/mudgen/how-diamond-storage-works-90e)\n * is used to set the struct at a specific place in contract storage. The pattern\n * recommends that the hash of a specific namespace (e.g. \"requiem.treasury.storage\")\n * be used as the slot to store the struct.\n *\n * Additionally, the Diamond Storage pattern can be used to access and change state inside\n * of Library contract code (https://dev.to/mudgen/solidity-libraries-can-t-have-state-variables-oh-yes-they-can-3ke9).\n * Instead of using `LibStorage.treasuryStorage()` directly, a Library will probably\n * define a convenience function to accessing state, similar to the `gs()` function provided\n * in the `WithStorage` base contract below.\n *\n * This pattern was chosen over the AppStorage pattern (https://dev.to/mudgen/appstorage-pattern-for-state-variables-in-solidity-3lki)\n * because AppStorage seems to indicate it doesn't support additional state in contracts.\n * This becomes a problem when using base contracts that manage their own state internally.\n *\n * There are a few caveats to this approach:\n * 1. State must always be loaded through a function (`LibStorage.treasuryStorage()`)\n *    instead of accessing it as a variable directly. The `WithStorage` base contract\n *    below provides convenience functions, such as `gs()`, for accessing storage.\n * 2. Although inherited contracts can have their own state, top level contracts must\n *    ONLY use the Diamond Storage. This seems to be due to how contract inheritance\n *    calculates contract storage layout.\n * 3. The same namespace can't be used for multiple structs. However, new namespaces can\n *    be added to the contract to add additional storage structs.\n * 4. If a contract is deployed using the Diamond Storage, you must ONLY ADD fields to the\n *    very end of the struct during upgrades. During an upgrade, if any fields get added,\n *    removed, or changed at the beginning or middle of the existing struct, the\n *    entire layout of the storage will be broken.\n * 5. Avoid structs within the Diamond Storage struct, as these nested structs cannot be\n *    changed during upgrades without breaking the layout of storage. Structs inside of\n *    mappings are fine because their storage layout is different. Consider creating a new\n *    Diamond storage for each struct.\n *\n * More information on Solidity contract storage layout is available at:\n * https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html\n *\n * Nick Mudge, the author of the Diamond Pattern and creator of Diamond Storage pattern,\n * wrote about the benefits of the Diamond Storage pattern over other storage patterns at\n * https://medium.com/1milliondevs/new-storage-layout-for-proxy-contracts-and-diamonds-98d01d0eadb#bfc1\n */\nlibrary LibStorage {\n    // Storage are structs where the data gets updated throughout the lifespan of the project\n    bytes32 constant TREASURY_STORAGE = keccak256(\"requiem.storage.treasury\");\n    bytes32 constant QUEUE_STORAGE = keccak256(\"requiem.storage.queue\");\n    bytes32 constant MANAGEMENT_STORAGE = keccak256(\"requiem.storage.authority\");\n\n    function treasuryStorage() internal pure returns (TreasuryStorage storage ts) {\n        bytes32 position = TREASURY_STORAGE;\n        assembly {\n            ts.slot := position\n        }\n    }\n\n    function queueStorage() internal pure returns (QueueStorage storage qs) {\n        bytes32 position = QUEUE_STORAGE;\n        assembly {\n            qs.slot := position\n        }\n    }\n\n    function managementStorage() internal pure returns (ManagementStorage storage ms) {\n        bytes32 position = MANAGEMENT_STORAGE;\n        assembly {\n            ms.slot := position\n        }\n    }\n\n    // Authority access control\n    function enforcePolicy() internal view {\n        require(msg.sender == managementStorage().policy, \"Treasury: Must be policy\");\n    }\n\n    function enforceGovernor() internal view {\n        require(msg.sender == managementStorage().governor, \"Treasury: Must be governor\");\n    }\n\n    function enforceGuardian() internal view {\n        require(msg.sender == managementStorage().guardian, \"Treasury: Must be guardian\");\n    }\n\n    function enforceVault() internal view {\n        require(msg.sender == managementStorage().guardian, \"Treasury: Must be vault\");\n    }\n}\n\n/**\n * The `WithStorage` contract provides a base contract for Facet contracts to inherit.\n *\n * It mainly provides internal helpers to access the storage structs, which reduces\n * calls like `LibStorage.treasuryStorage()` to just `ts()`.\n *\n * To understand why the storage stucts must be accessed using a function instead of a\n * state variable, please refer to the documentation above `LibStorage` in this file.\n */\ncontract WithStorage {\n    function ts() internal pure returns (TreasuryStorage storage) {\n        return LibStorage.treasuryStorage();\n    }\n\n    function qs() internal pure returns (QueueStorage storage) {\n        return LibStorage.queueStorage();\n    }\n\n    function ms() internal pure returns (ManagementStorage storage) {\n        return LibStorage.managementStorage();\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IManagement.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IManagement {\n    /* ========== EVENTS ========== */\n\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n\n    function governor() external view returns (address);\n\n    function guardian() external view returns (address);\n\n    function policy() external view returns (address);\n\n    function vault() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IREQ.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IREQ is IERC20 {\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "contracts/interfaces/ICreditREQ.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\ninterface ICreditREQ {\n  function changeDebt(\n    uint256 amount,\n    address debtor,\n    bool add\n  ) external;\n\n  function debtBalances(address _address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/test/TestFacets/TreasuryFacetV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../MockUpgrade/LibStorageV2.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IERC20Metadata.sol\";\nimport \"../../interfaces/ICreditREQ.sol\";\nimport \"../../interfaces/IAssetPricer.sol\";\nimport \"../../interfaces/ITreasury.sol\";\n\ncontract TreasuryFacetV2 is ITreasury, WithStorage {\n    using SafeERC20 for IERC20;\n\n    /* ========== EVENTS ========== */\n    event Deposit(address indexed token, uint256 amount, uint256 value);\n    event Withdrawal(address indexed token, uint256 amount, uint256 value);\n    event CreateDebt(address indexed debtor, address indexed token, uint256 amount, uint256 value);\n    event RepayDebt(address indexed debtor, address indexed token, uint256 amount, uint256 value);\n    event Managed(address indexed token, uint256 amount);\n    event ReservesAudited(uint256 indexed totalReserves);\n    event Minted(address indexed caller, address indexed recipient, uint256 amount);\n    event PermissionQueued(uint256 indexed status, address queued);\n    event Permissioned(address addr, uint256 indexed status, bool result);\n\n    string internal notAccepted = \"Treasury: not accepted\";\n    string internal notApproved = \"Treasury: not approved\";\n    string internal invalidAsset = \"Treasury: invalid asset\";\n    string internal insufficientReserves = \"Treasury: insufficient reserves\";\n\n    // administrative\n    modifier onlyGovernor() {\n        LibStorage.enforceGovernor();\n        _;\n    }\n\n    modifier onlyPolicy() {\n        LibStorage.enforcePolicy();\n        _;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice allow approved address to deposit an asset for ts().REQ\n     * @param _amount uint256\n     * @param _token address\n     * @param _profit uint256\n     * @return send_ uint256\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external override returns (uint256 send_) {\n        if (ts().permissions[1][_token]) {\n            require(ts().permissions[0][msg.sender], notApproved);\n        } else {\n            revert(invalidAsset);\n        }\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 value = assetValue(_token, _amount);\n        // mint needed and store amount of rewards for distribution\n        send_ = value - _profit;\n        ts().REQ.mint(msg.sender, send_);\n\n        ts().totalReserves += value;\n\n        emit Deposit(_token, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to burn REQ for reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function withdraw(uint256 _amount, address _asset) external override {\n        require(ts().permissions[1][_asset], notAccepted); // Only reserves can be used for redemptions\n        require(ts().permissions[2][msg.sender], notApproved);\n\n        uint256 value = assetValue(_asset, _amount);\n        ts().REQ.burnFrom(msg.sender, value);\n\n        ts().totalReserves -= value;\n\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n\n        emit Withdrawal(_asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to withdraw assets\n     * @param _asset address\n     * @param _amount uint256\n     */\n    function manage(address _asset, uint256 _amount) external override {\n        require(ts().permissions[2][msg.sender], notApproved);\n\n        if (ts().permissions[1][_asset]) {\n            uint256 value = assetValue(_asset, _amount);\n            if (ts().useExcessReserves) require(int256(value) <= excessReserves(), insufficientReserves);\n\n            ts().totalReserves -= value;\n        }\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n        emit Managed(_asset, _amount);\n    }\n\n    /**\n     * @notice mint new ts().REQ using excess reserves\n     * @param _recipient address\n     * @param _amount uint256\n     */\n    function mint(address _recipient, uint256 _amount) external override {\n        require(ts().permissions[3][msg.sender], notApproved);\n        if (ts().useExcessReserves) require(int256(_amount) <= excessReserves(), insufficientReserves);\n\n        ts().REQ.mint(_recipient, _amount);\n        emit Minted(msg.sender, _recipient, _amount);\n    }\n\n    /**\n     * DEBT: The debt functions allow approved addresses to borrow treasury assets\n     * or ts().REQ from the treasury, using sts().REQ as collateral. This might allow an\n     * sts().REQ holder to provide ts().REQ liquidity without taking on the opportunity cost\n     * of unstaking, or alter their backing without imposing risk onto the treasury.\n     * Many of these use cases are yet to be defined, but they appear promising.\n     * However, we urge the community to think critically and move slowly upon\n     * proposals to acquire these ts().permissions.\n     */\n\n    /**\n     * @notice allow approved address to borrow reserves\n     * @param _amount uint256\n     * @param _token address\n     */\n    function incurDebt(uint256 _amount, address _token) external override {\n        uint256 value;\n        require(ts().permissions[5][msg.sender], notApproved);\n\n        if (_token == address(ts().REQ)) {\n            value = _amount;\n        } else {\n            value = assetValue(_token, _amount);\n        }\n        require(value != 0, invalidAsset);\n\n        ts().CREQ.changeDebt(value, msg.sender, true);\n        require(ts().CREQ.debtBalances(msg.sender) <= ts().debtLimits[msg.sender], \"Treasury: exceeds limit\");\n        ts().totalDebt += value;\n\n        if (_token == address(ts().REQ)) {\n            ts().REQ.mint(msg.sender, value);\n            ts().reqDebt += value;\n        } else {\n            ts().totalReserves -= value;\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n        }\n        emit CreateDebt(msg.sender, _token, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with reserves\n     * @param _amount uint256\n     * @param _token address\n     */\n    function repayDebtWithReserve(uint256 _amount, address _token) external override {\n        require(ts().permissions[5][msg.sender], notApproved);\n        require(ts().permissions[1][_token], notAccepted);\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 value = assetValue(_token, _amount);\n        ts().CREQ.changeDebt(value, msg.sender, false);\n        ts().totalDebt -= value;\n        ts().totalReserves += value;\n        emit RepayDebt(msg.sender, _token, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with REQ\n     * @param _amount uint256\n     */\n    function repayDebtWithREQ(uint256 _amount) external {\n        require(ts().permissions[5][msg.sender], notApproved);\n        ts().REQ.burnFrom(msg.sender, _amount);\n        ts().CREQ.changeDebt(_amount, msg.sender, false);\n        ts().totalDebt -= _amount;\n        ts().reqDebt -= _amount;\n        emit RepayDebt(msg.sender, address(ts().REQ), _amount, _amount);\n    }\n\n    /* ========== MANAGERIAL FUNCTIONS ========== */\n\n    /**\n     * @notice takes inventory of all tracked assets\n     * @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external onlyGovernor {\n        uint256 reserves;\n        address[] memory assets = ts().registry[1];\n        for (uint256 i = 0; i < assets.length; i++) {\n            if (ts().permissions[1][assets[i]]) {\n                reserves += assetValue(assets[i], IERC20(assets[i]).balanceOf(address(this)));\n            }\n        }\n        ts().totalReserves = reserves;\n        emit ReservesAudited(reserves);\n    }\n\n    /**\n     * @notice set max debt for address\n     * @param _address address\n     * @param _limit uint256\n     */\n    function setDebtLimit(address _address, uint256 _limit) external onlyGovernor {\n        ts().debtLimits[_address] = _limit;\n    }\n\n     /**\n     * @notice enable permission from queue\n     * @param _status STATUS\n     * @param _address address\n     * @param _pricer address\n     * @param _quote address\n     */\n    function enable(\n        uint256 _status,\n        address _address,\n        address _pricer,\n        address _quote\n    ) external {\n        require(!ts().timelockEnabled, \"Use queueTimelock\");\n        if (_status == 7) {\n            ts().CREQ = ICreditREQ(_address);\n        } else {\n            ts().permissions[_status][_address] = true;\n\n            if (_status == 1) {\n                ts().assetPricer[_address] = _pricer;\n                ts().quotes[_address] = _quote;\n            }\n\n            (bool registered, ) = indexInRegistry(_address, _status);\n            if (!registered) {\n                ts().registry[_status].push(_address);\n            }\n        }\n        emit Permissioned(_address, _status, true);\n    }\n\n    /**\n     *  @notice disable permission from address\n     *  @param _status STATUS\n     *  @param _toDisable address\n     */\n    function disable(uint256 _status, address _toDisable) external {\n        require(msg.sender == ms().governor || msg.sender == ms().guardian, \"Only governor or guardian\");\n        ts().permissions[_status][_toDisable] = false;\n        emit Permissioned(_toDisable, _status, false);\n    }\n\n    /**\n     * @notice check if ts().registry contains address\n     * @return (bool, uint256)\n     */\n    function indexInRegistry(address _address, uint256 _status) public view returns (bool, uint256) {\n        address[] memory entries = ts().registry[_status];\n        for (uint256 i = 0; i < entries.length; i++) {\n            if (_address == entries[i]) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @notice changes the use of excess reserves for minting\n     */\n    function setUseExcessReserves() external {\n        ts().useExcessReserves = !ts().useExcessReserves;\n    }\n\n    /* ========== TIMELOCKED FUNCTIONS ========== */\n\n    // functions are used prior to enabling on-chain governance\n\n    /**\n     * @notice queue address to receive permission\n     * @param _status STATUS\n     * @param _address address\n     * @param _calculator address\n     */\n    function queueTimelock(\n        uint256 _status,\n        address _address,\n        address _calculator,\n        address\n    ) external onlyGovernor {\n        require(_address != address(0));\n        require(ts().timelockEnabled == true, \"Timelock is disabled, use enable\");\n\n        uint256 timelock = block.number + ts().blocksNeededForQueue;\n        if (_status == 2) {\n            timelock = block.number + ts().blocksNeededForQueue * 2;\n        }\n        ts().permissionQueue.push(\n            Queue({managing: _status, toPermit: _address, calculator: _calculator, timelockEnd: timelock, nullify: false, executed: false})\n        );\n        emit PermissionQueued(_status, _address);\n    }\n\n    /**\n     *  @notice enable queued permission\n     *  @param _index uint256\n     */\n    function execute(uint256 _index) external {\n        require(ts().timelockEnabled == true, \"Timelock is disabled, use enable\");\n\n        Queue memory info = ts().permissionQueue[_index];\n\n        require(!info.nullify, \"Action has been nullified\");\n        require(!info.executed, \"Action has already been executed\");\n        require(block.number >= info.timelockEnd, \"Timelock not complete\");\n\n        if (info.managing == 7) {\n            // 9\n            ts().CREQ = ICreditREQ(info.toPermit);\n        } else {\n            ts().permissions[info.managing][info.toPermit] = true;\n\n            if (info.managing == 1) {\n                ts().assetPricer[info.toPermit] = info.calculator;\n            }\n            (bool registered, ) = indexInRegistry(info.toPermit, info.managing);\n            if (!registered) {\n                ts().registry[info.managing].push(info.toPermit);\n\n                if (info.managing == 1) {\n                    (bool reg, uint256 index) = indexInRegistry(info.toPermit, 1);\n                    if (reg) {\n                        delete ts().registry[1][index];\n                    }\n                }\n            }\n        }\n        ts().permissionQueue[_index].executed = true;\n        emit Permissioned(info.toPermit, info.managing, true);\n    }\n\n    /**\n     * @notice cancel timelocked action\n     * @param _index uint256\n     */\n    function nullify(uint256 _index) external onlyGovernor {\n        ts().permissionQueue[_index].nullify = true;\n    }\n\n    /**\n     * @notice disables timelocked functions\n     */\n    function disableTimelock() external onlyGovernor {\n        require(ts().timelockEnabled == true, \"timelock already disabled\");\n        if (ts().onChainGovernanceTimelock != 0 && ts().onChainGovernanceTimelock <= block.number) {\n            ts().timelockEnabled = false;\n        } else {\n            ts().onChainGovernanceTimelock = block.number + ts().blocksNeededForQueue * 7; // 7-day timelock\n        }\n    }\n\n    /**\n     * @notice enables timelocks after initilization\n     */\n    function enableTimelock(uint256 _blocksNeededForQueue) external onlyGovernor {\n        require(!ts().timelockEnabled, \"timelock already enabled\");\n        ts().timelockEnabled = true;\n        ts().blocksNeededForQueue = _blocksNeededForQueue;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice returns excess reserves not backing tokens\n     * @return int\n     */\n    function excessReserves() public view returns (int256) {\n        return int256(ts().totalReserves) - int256(ts().REQ.totalSupply() - ts().totalDebt);\n    }\n\n    /**\n     * @notice returns REQ valuation of asset\n     * @param _token address\n     * @param _amount uint256\n     * @return value_ uint256\n     */\n    function assetValue(address _token, uint256 _amount) public view override returns (uint256 value_) {\n        if (ts().permissions[1][_token]) {\n            value_ = IAssetPricer(ts().assetPricer[_token]).valuation(_token, address(0), _amount);\n        } else {\n            revert(invalidAsset);\n        }\n    }\n\n    /**\n     * @notice returns internal REQ valuation of asset\n     * @param _asset address\n     * @param _amount uint256\n     * @return value_ uint256\n     */\n    function slashedAssetValue(address _asset, uint256 _amount) public view returns (uint256 value_) {\n        if (ts().permissions[1][_asset]) {\n            value_ = IAssetPricer(ts().assetPricer[_asset]).slashedValuation(_asset, ts().quotes[_asset], _amount);\n        } else {\n            revert(\"Treasury: invalid asset\");\n        }\n    }\n\n    /**\n     * @notice returns supply metric that cannot be manipulated by debt\n     * @dev use this any time you need to query supply\n     * @return uint256\n     */\n    function baseSupply() external view override returns (uint256) {\n        return ts().REQ.totalSupply() - ts().reqDebt;\n    }\n\n    // VIEWS FROM STORAGE\n\n    function assetPricer(address _entry) external view returns (address) {\n        return ts().assetPricer[_entry];\n    }\n\n    function registry(uint256 _status, uint256 _entry) external view returns (address) {\n        return ts().registry[_status][_entry];\n    }\n\n    function permissions(uint256 _status, address _entry) external view returns (bool) {\n        return ts().permissions[_status][_entry];\n    }\n\n    function debtLimits(address _asset) public view returns (uint256) {\n        return ts().debtLimits[_asset];\n    }\n\n    function assetReserves(address _asset) public view returns (uint256) {\n        return ts().assetReserves[_asset];\n    }\n\n    function totalReserves() public view returns (uint256) {\n        return ts().totalReserves;\n    }\n\n    function totalDebt() public view returns (uint256) {\n        return ts().totalDebt;\n    }\n\n    function permissionQueue(uint256 _index) public view returns (Queue memory) {\n        return ts().permissionQueue[_index];\n    }\n\n    function lastPermissionQueueIndex() public view returns (uint256) {\n        return qs().currentIndex;\n    }\n\n    function timelockEnabled() public view returns (bool) {\n        return ts().timelockEnabled;\n    }\n\n    function useExcessReserves() public view returns (bool) {\n        return ts().useExcessReserves;\n    }\n\n    function onChainGovernanceTimelock() public view returns (uint256) {\n        return ts().onChainGovernanceTimelock;\n    }\n\n    function REQ() public view returns (IREQ) {\n        return ts().REQ;\n    }\n\n    function CREQ() public view returns (ICreditREQ) {\n        return ts().CREQ;\n    }\n\n    function newFunction() public pure returns (uint256) {\n        return 7;\n    }\n\n    function setNewValue(uint256 _newVal) public {\n        ns().addedValue = _newVal;\n    }\n\n    function newValue() public view returns (uint256) {\n        return ns().addedValue;\n    }\n}\n"
    },
    "contracts/test/MockUpgrade/LibStorageV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IREQ.sol\";\nimport \"../../interfaces/ICreditREQ.sol\";\nimport \"../../libraries/LibDiamond.sol\";\n\n// enum here jsut for reference - uint256 used for upgradability\n// enum STATUS {\n//     ASSETDEPOSITOR, =0\n//     ASSET, = 1\n//     ASSETMANAGER, = 2\n//     REWARDMANAGER, = 3\n//     DEBTMANAGER, = 4\n//     DEBTOR, = 5\n//     COLLATERAL, = 6\n//     CREQ = 7\n// }\n\nstruct Queue {\n    // STATUS managing;\n    uint256 managing;\n    address toPermit;\n    address calculator;\n    uint256 timelockEnd;\n    bool nullify;\n    bool executed;\n}\n\nstruct QueueStorage {\n    uint256 currentIndex;\n    mapping(uint256 => uint256) managing;\n    mapping(uint256 => address) toPermit;\n    mapping(uint256 => address) pricer;\n    mapping(uint256 => address) quote;\n    mapping(uint256 => uint256) timelockEnd;\n    mapping(uint256 => bool) nullify;\n    mapping(uint256 => bool) executed;\n}\n\nstruct ManagementStorage {\n    address governor;\n    address guardian;\n    address policy;\n    address vault;\n    address newGovernor;\n    address newGuardian;\n    address newPolicy;\n    address newVault;\n}\n\nstruct TreasuryStorageV2 {\n    // requiem global assets\n    IREQ REQ;\n    ICreditREQ CREQ;\n    // general registers\n    mapping(uint256 => address[]) registry;\n    mapping(uint256 => mapping(address => bool)) permissions;\n    mapping(address => address) assetPricer;\n    mapping(address => address) quotes;\n    mapping(address => uint256) debtLimits;\n    // asset data\n    mapping(address => uint256) assetReserves;\n    mapping(address => uint256) assetDebt;\n    // aggregted data\n    uint256 totalReserves;\n    uint256 totalDebt;\n    uint256 reqDebt;\n    Queue[] permissionQueue;\n    uint256 blocksNeededForQueue;\n    bool timelockEnabled;\n    bool useExcessReserves;\n    uint256 onChainGovernanceTimelock;\n    uint256 testField;\n}\n\nstruct NewStorage {\n    uint256 addedValue;\n}\n\n/**\n * All of Requiems's treasury storage is stored in a single TreasuryStorage struct.\n *\n * The Diamond Storage pattern (https://dev.to/mudgen/how-diamond-storage-works-90e)\n * is used to set the struct at a specific place in contract storage. The pattern\n * recommends that the hash of a specific namespace (e.g. \"requiem.treasury.storage\")\n * be used as the slot to store the struct.\n *\n * Additionally, the Diamond Storage pattern can be used to access and change state inside\n * of Library contract code (https://dev.to/mudgen/solidity-libraries-can-t-have-state-variables-oh-yes-they-can-3ke9).\n * Instead of using `LibStorage.treasuryStorage()` directly, a Library will probably\n * define a convenience function to accessing state, similar to the `gs()` function provided\n * in the `WithStorage` base contract below.\n *\n * This pattern was chosen over the AppStorage pattern (https://dev.to/mudgen/appstorage-pattern-for-state-variables-in-solidity-3lki)\n * because AppStorage seems to indicate it doesn't support additional state in contracts.\n * This becomes a problem when using base contracts that manage their own state internally.\n *\n * There are a few caveats to this approach:\n * 1. State must always be loaded through a function (`LibStorage.treasuryStorage()`)\n *    instead of accessing it as a variable directly. The `WithStorage` base contract\n *    below provides convenience functions, such as `gs()`, for accessing storage.\n * 2. Although inherited contracts can have their own state, top level contracts must\n *    ONLY use the Diamond Storage. This seems to be due to how contract inheritance\n *    calculates contract storage layout.\n * 3. The same namespace can't be used for multiple structs. However, new namespaces can\n *    be added to the contract to add additional storage structs.\n * 4. If a contract is deployed using the Diamond Storage, you must ONLY ADD fields to the\n *    very end of the struct during upgrades. During an upgrade, if any fields get added,\n *    removed, or changed at the beginning or middle of the existing struct, the\n *    entire layout of the storage will be broken.\n * 5. Avoid structs within the Diamond Storage struct, as these nested structs cannot be\n *    changed during upgrades without breaking the layout of storage. Structs inside of\n *    mappings are fine because their storage layout is different. Consider creating a new\n *    Diamond storage for each struct.\n *\n * More information on Solidity contract storage layout is available at:\n * https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html\n *\n * Nick Mudge, the author of the Diamond Pattern and creator of Diamond Storage pattern,\n * wrote about the benefits of the Diamond Storage pattern over other storage patterns at\n * https://medium.com/1milliondevs/new-storage-layout-for-proxy-contracts-and-diamonds-98d01d0eadb#bfc1\n */\nlibrary LibStorage {\n    // Storage are structs where the data gets updated throughout the lifespan of the project\n    bytes32 constant TREASURY_STORAGE = keccak256(\"requiem.storage.treasury\");\n    bytes32 constant QUEUE_STORAGE = keccak256(\"requiem.storage.queue\");\n    bytes32 constant MANAGEMENT_STORAGE = keccak256(\"requiem.storage.authority\");\n\n    function treasuryStorage() internal pure returns (TreasuryStorageV2 storage ts) {\n        bytes32 position = TREASURY_STORAGE;\n        assembly {\n            ts.slot := position\n        }\n    }\n\n    function managementStorage() internal pure returns (ManagementStorage storage ms) {\n        bytes32 position = MANAGEMENT_STORAGE;\n        assembly {\n            ms.slot := position\n        }\n    }\n\n    function queueStorage() internal pure returns (QueueStorage storage qs) {\n        bytes32 position = QUEUE_STORAGE;\n        assembly {\n            qs.slot := position\n        }\n    }\n\n    // Authority access control\n    function enforcePolicy() internal view {\n        require(msg.sender == managementStorage().policy, \"Treasury: Must be policy\");\n    }\n\n    function enforceGovernor() internal view {\n        require(msg.sender == managementStorage().governor, \"Treasury: Must be governor\");\n    }\n\n    function enforceGuardian() internal view {\n        require(msg.sender == managementStorage().guardian, \"Treasury: Must be guardian\");\n    }\n\n    function enforceVault() internal view {\n        require(msg.sender == managementStorage().guardian, \"Treasury: Must be vault\");\n    }\n\n    // Storage are structs where the data gets updated throughout the lifespan of the project\n    bytes32 constant ADDED_STORAGE = keccak256(\"requiem.storage.added\");\n\n    function newStorage() internal pure returns (NewStorage storage ns) {\n        bytes32 position = ADDED_STORAGE;\n        assembly {\n            ns.slot := position\n        }\n    }\n}\n\n/**\n * The `WithStorage` contract provides a base contract for Facet contracts to inherit.\n *\n * It mainly provides internal helpers to access the storage structs, which reduces\n * calls like `LibStorage.gameStorage()` to just `gs()`.\n *\n * To understand why the storage stucts must be accessed using a function instead of a\n * state variable, please refer to the documentation above `LibStorage` in this file.\n */\ncontract WithStorage {\n    function ts() internal pure returns (TreasuryStorageV2 storage) {\n        return LibStorage.treasuryStorage();\n    }\n\n    function ms() internal pure returns (ManagementStorage storage) {\n        return LibStorage.managementStorage();\n    }\n\n    function qs() internal pure returns (QueueStorage storage) {\n        return LibStorage.queueStorage();\n    }\n\n    // extended storage\n    function ns() internal pure returns (NewStorage storage) {\n        return LibStorage.newStorage();\n    }\n}\n"
    },
    "contracts/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce gas costs.\n// The `safeTransfer` and `safeTransferFrom` functions assume that `token` is a contract (an account with code), and\n// work differently from the OpenZeppelin version if it is not.\n\npragma solidity ^0.8.15;\n\nimport \"../interfaces/IERC20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   *\n   * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\n   */\n  function _callOptionalReturn(address token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves.\n    (bool success, bytes memory returndata) = token.call(data);\n\n    // If the low-level call didn't succeed we return whatever was returned from it.\n    assembly {\n      if eq(success, 0) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\n    require(\n      returndata.length == 0 || abi.decode(returndata, (bool)),\n      \"SAFE_ERC20_CALL_FAILED\"\n    );\n  }\n}\n"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/interfaces/IAssetPricer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\ninterface IAssetPricer {\n    function valuation(\n        address _asset,\n        address _quote,\n        uint256 _amount\n    ) external view returns (uint256);\n\n    function slashedValuation(\n        address _pair,\n        address _quote,\n        uint256 _amount\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function assetValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (int256);\n\n    function baseSupply() external view returns (uint256);\n}\n"
    },
    "contracts/test/MockDepo.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract MockDepo {\n    ITreasury treasury;\n\n    constructor(address _treasury) {\n        treasury = ITreasury(_treasury);\n    }\n\n    function depositForREQ(address _asset, uint256 _amount) public {\n        treasury.deposit(_amount, _asset, 10);\n    }\n\n    function mintREQFor(address _asset, uint256 _amount) public {\n        uint256 _vl = treasury.assetValue(_asset, _amount);\n        IERC20(_asset).transferFrom(msg.sender, address(treasury), _amount);\n        treasury.mint(msg.sender, _vl);\n    }\n}\n"
    },
    "contracts/test/MockAssetPricer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IAssetPricer.sol\";\n\ncontract MockAssetPricer is IAssetPricer {\n    IERC20 public REQ;\n\n    uint256 scalar;\n\n    constructor(address _req, uint256 _scalar) {\n        require(_req != address(0), \"Cannot be 0 address\");\n        REQ = IERC20(_req);\n        scalar = _scalar;\n    }\n\n    function valuation(\n        address _asset,\n        address,\n        uint256 _amount\n    ) external view override returns (uint256) {\n        return (scalar * _amount * 10**(REQ.decimals() - IERC20(_asset).decimals())) / 1e18;\n    }\n\n    function slashedValuation(\n        address _asset,\n        address,\n        uint256 _amount\n    ) external view override returns (uint256) {\n        return (scalar * _amount * 10**(REQ.decimals() - IERC20(_asset).decimals())) / 1e18;\n    }\n}\n"
    },
    "contracts/oldFacets/v01/TreasuryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../../libraries/LibStorage.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IERC20Metadata.sol\";\nimport \"../../interfaces/ICreditREQ.sol\";\nimport \"../../interfaces/IAssetPricer.sol\";\nimport \"../../interfaces/ITreasury.sol\";\n\n// the managing / status input is coded as follows:\n// enum STATUS {\n//     ASSETDEPOSITOR, = 0\n//     ASSET, = 1\n//     ASSETMANAGER, = 2\n//     REWARDMANAGER, = 3\n//     DEBTMANAGER, = 4\n//     DEBTOR, = 5\n//     COLLATERAL, = 6\n//     CREQ = 7\n// }\n\n// Local Queue struct outside of LibStorage to keep upgradeability\n// The managing field uses the indexing according to the commented enum above\n// We use uint256 as enums are not upgradeable.\nstruct Queue {\n    uint256 managing;\n    address toPermit;\n    address pricer;\n    uint256 timelockEnd;\n    bool nullify;\n    bool executed;\n    address quote;\n}\n\n// Helper library to enable upgradeable queuing\n// It just uses the current state of the queue storage and parses it to\n// the Queue struct above - which avoids using arrays or mappings of structs\n// Gas cost is not too important here as these are only used in rare cases\nlibrary QueueStorageLib {\n    function push(QueueStorage storage self, Queue memory newEntry) internal {\n        uint256 newIndex = self.currentIndex + 1;\n        self.currentIndex = newIndex;\n        self.managing[newIndex] = newEntry.managing;\n        self.toPermit[newIndex] = newEntry.toPermit;\n        self.pricer[newIndex] = newEntry.pricer;\n        self.timelockEnd[newIndex] = newEntry.timelockEnd;\n        self.nullify[newIndex] = newEntry.nullify;\n        self.executed[newIndex] = newEntry.executed;\n    }\n\n    function get(QueueStorage storage self, uint256 _index) internal view returns (Queue memory) {\n        require(_index <= self.currentIndex, \"Queue: Invalid index\");\n        return\n            Queue(\n                self.managing[_index],\n                self.toPermit[_index],\n                self.pricer[_index],\n                self.timelockEnd[_index],\n                self.nullify[_index],\n                self.executed[_index],\n                self.quote[_index]\n            );\n    }\n}\n\n// The treasury facet that contains the logic that changes the storage\n// Aligned with EIP-2535, the contract has no constructor or an own state\ncontract TreasuryFacet_001 is ITreasury, WithStorage {\n    using SafeERC20 for IERC20;\n    using QueueStorageLib for QueueStorage;\n\n    /* ========== EVENTS ========== */\n    event Deposit(address indexed asset, uint256 amount, uint256 value);\n    event Withdrawal(address indexed asset, uint256 amount, uint256 value);\n    event CreateDebt(address indexed debtor, address indexed asset, uint256 amount, uint256 value);\n    event RepayDebt(address indexed debtor, address indexed asset, uint256 amount, uint256 value);\n    event Managed(address indexed asset, uint256 amount);\n    event ReservesAudited(uint256 indexed totalReserves);\n    event Minted(address indexed caller, address indexed recipient, uint256 amount);\n    event PermissionQueued(uint256 indexed status, address queued);\n    event Permissioned(address addr, uint256 indexed status, bool result);\n\n    // administrative\n    modifier onlyGovernor() {\n        LibStorage.enforceGovernor();\n        _;\n    }\n\n    modifier onlyPolicy() {\n        LibStorage.enforcePolicy();\n        _;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice allow approved address to deposit an asset for ts().REQ\n     * @param _amount uint256\n     * @param _asset address\n     * @param _profit uint256\n     * @return send_ uint256\n     */\n    function deposit(\n        uint256 _amount,\n        address _asset,\n        uint256 _profit\n    ) external override returns (uint256 send_) {\n        if (ts().permissions[1][_asset]) {\n            require(ts().permissions[0][msg.sender], \"Treasury: not approved\");\n        } else {\n            revert(\"Treasury: invalid asset\");\n        }\n\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 value = assetValue(_asset, _amount);\n        // mint needed and store amount of rewards for distribution\n        send_ = value - _profit;\n        ts().REQ.mint(msg.sender, send_);\n\n        ts().totalReserves += value;\n\n        emit Deposit(_asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to burn REQ for reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function withdraw(uint256 _amount, address _asset) external override {\n        require(ts().permissions[1][_asset], \"Treasury: not accepted\");\n        require(ts().permissions[2][msg.sender], \"Treasury: not approved\");\n\n        uint256 value = assetValue(_asset, _amount);\n        ts().REQ.burnFrom(msg.sender, value);\n\n        ts().totalReserves -= value;\n\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n\n        emit Withdrawal(_asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to withdraw assets\n     * @param _asset address\n     * @param _amount uint256\n     */\n    function manage(address _asset, uint256 _amount) external override {\n        require(ts().permissions[2][msg.sender], \"Treasury: not approved\");\n\n        if (ts().permissions[1][_asset]) {\n            uint256 value = assetValue(_asset, _amount);\n            if (ts().useExcessReserves) require(int256(value) <= excessReserves(), \"Treasury: insufficient reserves\");\n\n            ts().totalReserves -= value;\n        }\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n        emit Managed(_asset, _amount);\n    }\n\n    /**\n     * @notice mint new REQ using excess reserves\n     * @param _recipient address\n     * @param _amount uint256\n     */\n    function mint(address _recipient, uint256 _amount) external override {\n        require(ts().permissions[3][msg.sender], \"Treasury: not approved\");\n        if (ts().useExcessReserves) require(int256(_amount) <= excessReserves(), \"Treasury: insufficient reserves\");\n\n        ts().REQ.mint(_recipient, _amount);\n        emit Minted(msg.sender, _recipient, _amount);\n    }\n\n    /**\n     * DEBT: The debt functions allow approved addresses to borrow treasury assets\n     * or REQ from the treasury, using CREQ as collateral. This might allow an\n     * CREQ holder to provide REQ liquidity without taking on the opportunity cost\n     * of unstaking, or alter their backing without imposing risk onto the treasury.\n     * Many of these use cases are yet to be defined, but they appear promising.\n     * However, we urge the community to think critically and move slowly upon\n     * proposals to acquire these permissions.\n     */\n\n    /**\n     * @notice allow approved address to borrow reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function incurDebt(uint256 _amount, address _asset) external override {\n        uint256 value;\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n\n        if (_asset == address(ts().REQ)) {\n            value = _amount;\n        } else {\n            value = assetValue(_asset, _amount);\n        }\n        require(value != 0, \"Treasury: invalid asset\");\n\n        ts().CREQ.changeDebt(value, msg.sender, true);\n        require(ts().CREQ.debtBalances(msg.sender) <= ts().debtLimits[msg.sender], \"Treasury: exceeds limit\");\n        ts().totalDebt += value;\n\n        if (_asset == address(ts().REQ)) {\n            ts().REQ.mint(msg.sender, value);\n            ts().reqDebt += value;\n        } else {\n            ts().totalReserves -= value;\n            IERC20(_asset).safeTransfer(msg.sender, _amount);\n        }\n        emit CreateDebt(msg.sender, _asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function repayDebtWithReserve(uint256 _amount, address _asset) external override {\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n        require(ts().permissions[1][_asset], \"Treasury: not accepted\");\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 value = assetValue(_asset, _amount);\n        ts().CREQ.changeDebt(value, msg.sender, false);\n        ts().totalDebt -= value;\n        ts().totalReserves += value;\n        emit RepayDebt(msg.sender, _asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with REQ\n     * @param _amount uint256\n     */\n    function repayDebtWithREQ(uint256 _amount) external {\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n        ts().REQ.burnFrom(msg.sender, _amount);\n        ts().CREQ.changeDebt(_amount, msg.sender, false);\n        ts().totalDebt -= _amount;\n        ts().reqDebt -= _amount;\n        emit RepayDebt(msg.sender, address(ts().REQ), _amount, _amount);\n    }\n\n    /* ========== MANAGERIAL FUNCTIONS ========== */\n\n    /**\n     * @notice takes inventory of all tracked assets\n     * @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external onlyGovernor {\n        uint256 reserves;\n        address[] memory assets = ts().registry[1];\n        for (uint256 i = 0; i < assets.length; i++) {\n            if (ts().permissions[1][assets[i]]) {\n                reserves += assetValue(assets[i], IERC20(assets[i]).balanceOf(address(this)));\n            }\n        }\n        ts().totalReserves = reserves;\n        emit ReservesAudited(reserves);\n    }\n\n    /**\n     * @notice set max debt for address\n     * @param _address address\n     * @param _limit uint256\n     */\n    function setDebtLimit(address _address, uint256 _limit) external onlyGovernor {\n        ts().debtLimits[_address] = _limit;\n    }\n\n    /**\n     * @notice enable permission from queue\n     * @param _status STATUS\n     * @param _address address\n     * @param _pricer address\n     */\n    function enable(\n        uint256 _status,\n        address _address,\n        address _pricer\n    ) external {\n        require(!ts().timelockEnabled, \"Use queueTimelock\");\n        if (_status == 7) {\n            ts().CREQ = ICreditREQ(_address);\n        } else {\n            ts().permissions[_status][_address] = true;\n\n            if (_status == 1) {\n                ts().assetPricer[_address] = _pricer;\n            }\n\n            (bool registered, ) = indexInRegistry(_address, _status);\n            if (!registered) {\n                ts().registry[_status].push(_address);\n\n                if (_status == 1) {\n                    (bool reg, uint256 index) = indexInRegistry(_address, _status);\n                    if (reg) {\n                        delete ts().registry[_status][index];\n                    }\n                }\n            }\n        }\n        emit Permissioned(_address, _status, true);\n    }\n\n    /**\n     *  @notice disable permission from address\n     *  @param _status STATUS\n     *  @param _toDisable address\n     */\n    function disable(uint256 _status, address _toDisable) external {\n        require(msg.sender == ms().governor || msg.sender == ms().guardian, \"Only governor or guardian\");\n        ts().permissions[_status][_toDisable] = false;\n        emit Permissioned(_toDisable, _status, false);\n    }\n\n    /**\n     * @notice check if ts().registry contains address\n     * @return (bool, uint256)\n     */\n    function indexInRegistry(address _address, uint256 _status) public view returns (bool, uint256) {\n        address[] memory entries = ts().registry[_status];\n        for (uint256 i = 0; i < entries.length; i++) {\n            if (_address == entries[i]) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @notice changes the use of excess reserves for minting\n     */\n    function setUseExcessReserves() external {\n        ts().useExcessReserves = !ts().useExcessReserves;\n    }\n\n    /* ========== TIMELOCKED FUNCTIONS ========== */\n\n    // functions are used prior to enabling on-chain governance\n\n    /**\n     * @notice queue address to receive permission\n     * @param _status STATUS\n     * @param _address address\n     * @param _pricer address\n     * @param _quote address\n     */\n    function queueTimelock(\n        uint256 _status,\n        address _address,\n        address _pricer,\n        address _quote\n    ) external onlyGovernor {\n        require(_address != address(0));\n        require(ts().timelockEnabled, \"Timelock is disabled, use enable\");\n        uint256 timelock = block.timestamp + ts().timeNeededForQueue;\n        if (_status == 2) {\n            timelock = block.timestamp + ts().timeNeededForQueue * 2;\n        }\n        if (_pricer != address(0)) {\n            require(_quote != address(0), \"Must provide quote\");\n        }\n\n        qs().push(\n            Queue({\n                managing: _status,\n                toPermit: _address,\n                pricer: _pricer,\n                timelockEnd: timelock,\n                nullify: false,\n                executed: false,\n                quote: _quote\n            })\n        );\n        emit PermissionQueued(_status, _address);\n    }\n\n    /**\n     *  @notice enable queued permission\n     *  @param _index uint256\n     */\n    function execute(uint256 _index) external {\n        require(ts().timelockEnabled == true, \"Timelock is disabled, use enable\");\n\n        Queue memory info = qs().get(_index);\n\n        require(!info.nullify, \"Action has been nullified\");\n        require(!info.executed, \"Action has already been executed\");\n        require(block.timestamp >= info.timelockEnd, \"Timelock not complete\");\n\n        if (info.managing == 7) {\n            ts().CREQ = ICreditREQ(info.toPermit);\n        } else {\n            ts().permissions[info.managing][info.toPermit] = true;\n\n            if (info.managing == 1) {\n                ts().assetPricer[info.toPermit] = info.pricer;\n                ts().quotes[info.toPermit] = info.quote;\n            }\n            (bool registered, ) = indexInRegistry(info.toPermit, info.managing);\n            if (!registered) {\n                ts().registry[info.managing].push(info.toPermit);\n\n                if (info.managing == 1) {\n                    (bool reg, uint256 index) = indexInRegistry(info.toPermit, 1);\n                    if (reg) {\n                        delete ts().registry[1][index];\n                    }\n                }\n            }\n        }\n        qs().executed[_index] = true;\n        emit Permissioned(info.toPermit, info.managing, true);\n    }\n\n    /**\n     * @notice cancel timelocked action\n     * @param _index uint256\n     */\n    function nullify(uint256 _index) external onlyGovernor {\n        qs().nullify[_index] = true;\n    }\n\n    /**\n     * @notice disables timelocked functions\n     */\n    function disableTimelock() external onlyGovernor {\n        require(ts().timelockEnabled, \"timelock already disabled\");\n        if (ts().onChainGovernanceTimelock != 0 && ts().onChainGovernanceTimelock <= block.timestamp) {\n            ts().timelockEnabled = false;\n        } else {\n            ts().onChainGovernanceTimelock = block.timestamp + ts().timeNeededForQueue * 7; // 7-day timelock\n        }\n    }\n\n    /**\n     * @notice enables timelocks after initilization\n     */\n    function enableTimelock(uint256 _timeNeededForQueue) external onlyGovernor {\n        require(!ts().timelockEnabled, \"timelock already enabled\");\n        ts().timelockEnabled = true;\n        ts().timeNeededForQueue = _timeNeededForQueue;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice returns excess reserves not backing assets\n     * @return int\n     */\n    function excessReserves() public view returns (int256) {\n        return int256(ts().totalReserves) - int256(ts().REQ.totalSupply() - ts().totalDebt);\n    }\n\n    /**\n     * @notice returns REQ valuation of asset\n     * @param _asset address\n     * @param _amount uint256\n     * @return value_ uint256\n     */\n    function assetValue(address _asset, uint256 _amount) public view override returns (uint256 value_) {\n        if (ts().permissions[1][_asset]) {\n            value_ = IAssetPricer(ts().assetPricer[_asset]).valuation(_asset, ts().quotes[_asset], _amount);\n        } else {\n            revert(\"Treasury: invalid asset\");\n        }\n    }\n\n    /**\n     * @notice returns supply metric that cannot be manipulated by debt\n     * @dev use this any time you need to query supply\n     * @return uint256\n     */\n    function baseSupply() external view override returns (uint256) {\n        return ts().REQ.totalSupply() - ts().reqDebt;\n    }\n\n    // VIEWS FROM STORAGE\n\n    function assetPricer(address _entry) external view returns (address) {\n        return ts().assetPricer[_entry];\n    }\n\n    function registry(uint256 _status, uint256 _entry) external view returns (address) {\n        return ts().registry[_status][_entry];\n    }\n\n    function permissions(uint256 _status, address _entry) external view returns (bool) {\n        return ts().permissions[_status][_entry];\n    }\n\n    function debtLimits(address _asset) public view returns (uint256) {\n        return ts().debtLimits[_asset];\n    }\n\n    function assetReserves(address _asset) public view returns (uint256) {\n        return ts().assetReserves[_asset];\n    }\n\n    function totalReserves() public view returns (uint256) {\n        return ts().totalReserves;\n    }\n\n    function totalDebt() public view returns (uint256) {\n        return ts().totalDebt;\n    }\n\n    function permissionQueue(uint256 _index) public view returns (Queue memory) {\n        return qs().get(_index);\n    }\n\n    function lastPermissionQueueIndex() public view returns (uint256) {\n        return qs().currentIndex;\n    }\n\n    function timelockEnabled() public view returns (bool) {\n        return ts().timelockEnabled;\n    }\n\n    function useExcessReserves() public view returns (bool) {\n        return ts().useExcessReserves;\n    }\n\n    function onChainGovernanceTimelock() public view returns (uint256) {\n        return ts().onChainGovernanceTimelock;\n    }\n\n    function REQ() public view returns (IREQ) {\n        return ts().REQ;\n    }\n\n    function CREQ() public view returns (ICreditREQ) {\n        return ts().CREQ;\n    }\n}\n"
    },
    "contracts/oldFacets/v00/TreasuryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../../libraries/LibStorage.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IERC20Metadata.sol\";\nimport \"../../interfaces/ICreditREQ.sol\";\nimport \"./IAssetPricer.sol\";\nimport \"../../interfaces/ITreasury.sol\";\n\n// the managing / status input is coded as follows:\n// enum STATUS {\n//     ASSETDEPOSITOR, = 0\n//     ASSET, = 1\n//     ASSETMANAGER, = 2\n//     REWARDMANAGER, = 3\n//     DEBTMANAGER, = 4\n//     DEBTOR, = 5\n//     COLLATERAL, = 6\n//     CREQ = 7\n// }\n\n// Local Queue struct outside of LibStorage to keep upgradeability\n// The managing field uses the indexing according to the commented enum above\n// We use uint256 as enums are not upgradeable.\nstruct Queue {\n    uint256 managing;\n    address toPermit;\n    address pricer;\n    uint256 timelockEnd;\n    bool nullify;\n    bool executed;\n}\n\n// Helper library to enable upgradeable queuing\n// It just uses the current state of the queue storage and parses it to\n// the Queue struct above - which avoids using arrays or mappings of structs\n// Gas cost is not too important here as these are only used in rare cases\nlibrary QueueStorageLib {\n    function push(QueueStorage storage self, Queue memory newEntry) internal {\n        uint256 newIndex = self.currentIndex + 1;\n        self.currentIndex = newIndex;\n        self.managing[newIndex] = newEntry.managing;\n        self.toPermit[newIndex] = newEntry.toPermit;\n        self.pricer[newIndex] = newEntry.pricer;\n        self.timelockEnd[newIndex] = newEntry.timelockEnd;\n        self.nullify[newIndex] = newEntry.nullify;\n        self.executed[newIndex] = newEntry.executed;\n    }\n\n    function get(QueueStorage storage self, uint256 _index) internal view returns (Queue memory) {\n        require(_index <= self.currentIndex && _index > 0, \"Queue: Invalid index\");\n        return\n            Queue(\n                self.managing[_index],\n                self.toPermit[_index],\n                self.pricer[_index],\n                self.timelockEnd[_index],\n                self.nullify[_index],\n                self.executed[_index]\n            );\n    }\n}\n\n// The treasury facet that contains the logic that changes the storage\n// Aligned with EIP-2535, the contract has no constructor or an own state\ncontract TreasuryFacet_000 is ITreasury, WithStorage {\n    using SafeERC20 for IERC20;\n    using QueueStorageLib for QueueStorage;\n\n    /* ========== EVENTS ========== */\n    event Deposit(address indexed asset, uint256 amount, uint256 value);\n    event Withdrawal(address indexed asset, uint256 amount, uint256 value);\n    event CreateDebt(address indexed debtor, address indexed asset, uint256 amount, uint256 value);\n    event RepayDebt(address indexed debtor, address indexed asset, uint256 amount, uint256 value);\n    event Managed(address indexed asset, uint256 amount);\n    event ReservesAudited(uint256 indexed totalReserves);\n    event Minted(address indexed caller, address indexed recipient, uint256 amount);\n    event PermissionQueued(uint256 indexed status, address queued);\n    event Permissioned(address addr, uint256 indexed status, bool result);\n\n    // administrative\n    modifier onlyGovernor() {\n        LibStorage.enforceGovernor();\n        _;\n    }\n\n    modifier onlyPolicy() {\n        LibStorage.enforcePolicy();\n        _;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice allow approved address to deposit an asset for ts().REQ\n     * @param _amount uint256\n     * @param _asset address\n     * @param _profit uint256\n     * @return send_ uint256\n     */\n    function deposit(\n        uint256 _amount,\n        address _asset,\n        uint256 _profit\n    ) external override returns (uint256 send_) {\n        if (ts().permissions[1][_asset]) {\n            require(ts().permissions[0][msg.sender], \"Treasury: not approved\");\n        } else {\n            revert(\"Treasury: invalid asset\");\n        }\n\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 value = assetValue(_asset, _amount);\n        // mint needed and store amount of rewards for distribution\n        send_ = value - _profit;\n        ts().REQ.mint(msg.sender, send_);\n\n        ts().totalReserves += value;\n\n        emit Deposit(_asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to burn REQ for reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function withdraw(uint256 _amount, address _asset) external override {\n        require(ts().permissions[1][_asset], \"Treasury: not accepted\");\n        require(ts().permissions[2][msg.sender], \"Treasury: not approved\");\n\n        uint256 value = assetValue(_asset, _amount);\n        ts().REQ.burnFrom(msg.sender, value);\n\n        ts().totalReserves -= value;\n\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n\n        emit Withdrawal(_asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to withdraw assets\n     * @param _asset address\n     * @param _amount uint256\n     */\n    function manage(address _asset, uint256 _amount) external override {\n        require(ts().permissions[2][msg.sender], \"Treasury: not approved\");\n\n        if (ts().permissions[1][_asset]) {\n            uint256 value = assetValue(_asset, _amount);\n            if (ts().useExcessReserves) require(int256(value) <= excessReserves(), \"Treasury: insufficient reserves\");\n\n            ts().totalReserves -= value;\n        }\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n        emit Managed(_asset, _amount);\n    }\n\n    /**\n     * @notice mint new ts().REQ using excess reserves\n     * @param _recipient address\n     * @param _amount uint256\n     */\n    function mint(address _recipient, uint256 _amount) external override {\n        require(ts().permissions[3][msg.sender], \"Treasury: not approved\");\n        if (ts().useExcessReserves) require(int256(_amount) <= excessReserves(), \"Treasury: insufficient reserves\");\n\n        ts().REQ.mint(_recipient, _amount);\n        emit Minted(msg.sender, _recipient, _amount);\n    }\n\n    /**\n     * DEBT: The debt functions allow approved addresses to borrow treasury assets\n     * or REQ from the treasury, using CREQ as collateral. This might allow an\n     * CREQ holder to provide REQ liquidity without taking on the opportunity cost\n     * of unstaking, or alter their backing without imposing risk onto the treasury.\n     * Many of these use cases are yet to be defined, but they appear promising.\n     * However, we urge the community to think critically and move slowly upon\n     * proposals to acquire these permissions.\n     */\n\n    /**\n     * @notice allow approved address to borrow reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function incurDebt(uint256 _amount, address _asset) external override {\n        uint256 value;\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n\n        if (_asset == address(ts().REQ)) {\n            value = _amount;\n        } else {\n            value = assetValue(_asset, _amount);\n        }\n        require(value != 0, \"Treasury: invalid asset\");\n\n        ts().CREQ.changeDebt(value, msg.sender, true);\n        require(ts().CREQ.debtBalances(msg.sender) <= ts().debtLimits[msg.sender], \"Treasury: exceeds limit\");\n        ts().totalDebt += value;\n\n        if (_asset == address(ts().REQ)) {\n            ts().REQ.mint(msg.sender, value);\n            ts().reqDebt += value;\n        } else {\n            ts().totalReserves -= value;\n            IERC20(_asset).safeTransfer(msg.sender, _amount);\n        }\n        emit CreateDebt(msg.sender, _asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function repayDebtWithReserve(uint256 _amount, address _asset) external override {\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n        require(ts().permissions[1][_asset], \"Treasury: not accepted\");\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 value = assetValue(_asset, _amount);\n        ts().CREQ.changeDebt(value, msg.sender, false);\n        ts().totalDebt -= value;\n        ts().totalReserves += value;\n        emit RepayDebt(msg.sender, _asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with REQ\n     * @param _amount uint256\n     */\n    function repayDebtWithREQ(uint256 _amount) external {\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n        ts().REQ.burnFrom(msg.sender, _amount);\n        ts().CREQ.changeDebt(_amount, msg.sender, false);\n        ts().totalDebt -= _amount;\n        ts().reqDebt -= _amount;\n        emit RepayDebt(msg.sender, address(ts().REQ), _amount, _amount);\n    }\n\n    /* ========== MANAGERIAL FUNCTIONS ========== */\n\n    /**\n     * @notice takes inventory of all tracked assets\n     * @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external onlyGovernor {\n        uint256 reserves;\n        address[] memory assets = ts().registry[1];\n        for (uint256 i = 0; i < assets.length; i++) {\n            if (ts().permissions[1][assets[i]]) {\n                reserves += assetValue(assets[i], IERC20(assets[i]).balanceOf(address(this)));\n            }\n        }\n        ts().totalReserves = reserves;\n        emit ReservesAudited(reserves);\n    }\n\n    /**\n     * @notice set max debt for address\n     * @param _address address\n     * @param _limit uint256\n     */\n    function setDebtLimit(address _address, uint256 _limit) external onlyGovernor {\n        ts().debtLimits[_address] = _limit;\n    }\n\n    /**\n     * @notice enable permission from queue\n     * @param _status STATUS\n     * @param _address address\n     * @param _pricer address\n     */\n    function enable(\n        uint256 _status,\n        address _address,\n        address _pricer\n    ) external {\n        require(!ts().timelockEnabled, \"Use queueTimelock\");\n        if (_status == 7) {\n            ts().CREQ = ICreditREQ(_address);\n        } else {\n            ts().permissions[_status][_address] = true;\n\n            if (_status == 1) {\n                ts().assetPricer[_address] = _pricer;\n            }\n\n            (bool registered, ) = indexInRegistry(_address, _status);\n            if (!registered) {\n                ts().registry[_status].push(_address);\n\n                if (_status == 1) {\n                    (bool reg, uint256 index) = indexInRegistry(_address, _status);\n                    if (reg) {\n                        delete ts().registry[_status][index];\n                    }\n                }\n            }\n        }\n        emit Permissioned(_address, _status, true);\n    }\n\n    /**\n     *  @notice disable permission from address\n     *  @param _status STATUS\n     *  @param _toDisable address\n     */\n    function disable(uint256 _status, address _toDisable) external {\n        require(msg.sender == ms().governor || msg.sender == ms().guardian, \"Only governor or guardian\");\n        ts().permissions[_status][_toDisable] = false;\n        emit Permissioned(_toDisable, _status, false);\n    }\n\n    /**\n     * @notice check if ts().registry contains address\n     * @return (bool, uint256)\n     */\n    function indexInRegistry(address _address, uint256 _status) public view returns (bool, uint256) {\n        address[] memory entries = ts().registry[_status];\n        for (uint256 i = 0; i < entries.length; i++) {\n            if (_address == entries[i]) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @notice changes the use of excess reserves for minting\n     */\n    function setUseExcessReserves() external {\n        ts().useExcessReserves = !ts().useExcessReserves;\n    }\n\n    /* ========== TIMELOCKED FUNCTIONS ========== */\n\n    // functions are used prior to enabling on-chain governance\n\n    /**\n     * @notice queue address to receive permission\n     * @param _status STATUS\n     * @param _address address\n     * @param _pricer address\n     */\n    function queueTimelock(\n        uint256 _status,\n        address _address,\n        address _pricer\n    ) external onlyGovernor {\n        require(_address != address(0));\n        require(ts().timelockEnabled, \"Timelock is disabled, use enable\");\n        uint256 timelock = block.timestamp + ts().timeNeededForQueue;\n        if (_status == 2) {\n            timelock = block.timestamp + ts().timeNeededForQueue * 2;\n        }\n        qs().push(Queue({managing: _status, toPermit: _address, pricer: _pricer, timelockEnd: timelock, nullify: false, executed: false}));\n        emit PermissionQueued(_status, _address);\n    }\n\n    /**\n     *  @notice enable queued permission\n     *  @param _index uint256\n     */\n    function execute(uint256 _index) external {\n        require(ts().timelockEnabled == true, \"Timelock is disabled, use enable\");\n\n        Queue memory info = qs().get(_index);\n\n        require(!info.nullify, \"Action has been nullified\");\n        require(!info.executed, \"Action has already been executed\");\n        require(block.timestamp >= info.timelockEnd, \"Timelock not complete\");\n\n        if (info.managing == 7) {\n            ts().CREQ = ICreditREQ(info.toPermit);\n        } else {\n            ts().permissions[info.managing][info.toPermit] = true;\n\n            if (info.managing == 1) {\n                ts().assetPricer[info.toPermit] = info.pricer;\n            }\n            (bool registered, ) = indexInRegistry(info.toPermit, info.managing);\n            if (!registered) {\n                ts().registry[info.managing].push(info.toPermit);\n\n                if (info.managing == 1) {\n                    (bool reg, uint256 index) = indexInRegistry(info.toPermit, 1);\n                    if (reg) {\n                        delete ts().registry[1][index];\n                    }\n                }\n            }\n        }\n        qs().executed[_index] = true;\n        emit Permissioned(info.toPermit, info.managing, true);\n    }\n\n    /**\n     * @notice cancel timelocked action\n     * @param _index uint256\n     */\n    function nullify(uint256 _index) external onlyGovernor {\n        qs().nullify[_index] = true;\n    }\n\n    /**\n     * @notice disables timelocked functions\n     */\n    function disableTimelock() external onlyGovernor {\n        require(ts().timelockEnabled, \"timelock already disabled\");\n        if (ts().onChainGovernanceTimelock != 0 && ts().onChainGovernanceTimelock <= block.timestamp) {\n            ts().timelockEnabled = false;\n        } else {\n            ts().onChainGovernanceTimelock = block.timestamp + ts().timeNeededForQueue * 7; // 7-day timelock\n        }\n    }\n\n    /**\n     * @notice enables timelocks after initilization\n     */\n    function enableTimelock(uint256 _timeNeededForQueue) external onlyGovernor {\n        require(!ts().timelockEnabled, \"timelock already enabled\");\n        ts().timelockEnabled = true;\n        ts().timeNeededForQueue = _timeNeededForQueue;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice returns excess reserves not backing assets\n     * @return int\n     */\n    function excessReserves() public view returns (int256) {\n        return int256(ts().totalReserves) - int256(ts().REQ.totalSupply() - ts().totalDebt);\n    }\n\n    /**\n     * @notice returns REQ valuation of asset\n     * @param _asset address\n     * @param _amount uint256\n     * @return value_ uint256\n     */\n    function assetValue(address _asset, uint256 _amount) public view override returns (uint256 value_) {\n        if (ts().permissions[1][_asset]) {\n            value_ = IAssetPricer(ts().assetPricer[_asset]).valuation(_asset, _amount);\n        } else {\n            revert(\"Treasury: invalid asset\");\n        }\n    }\n\n    /**\n     * @notice returns supply metric that cannot be manipulated by debt\n     * @dev use this any time you need to query supply\n     * @return uint256\n     */\n    function baseSupply() external view override returns (uint256) {\n        return ts().REQ.totalSupply() - ts().reqDebt;\n    }\n\n    // VIEWS FROM STORAGE\n\n    function assetPricer(address _entry) external view returns (address) {\n        return ts().assetPricer[_entry];\n    }\n\n    function registry(uint256 _status, uint256 _entry) external view returns (address) {\n        return ts().registry[_status][_entry];\n    }\n\n    function permissions(uint256 _status, address _entry) external view returns (bool) {\n        return ts().permissions[_status][_entry];\n    }\n\n    function debtLimits(address _asset) public view returns (uint256) {\n        return ts().debtLimits[_asset];\n    }\n\n    function assetReserves(address _asset) public view returns (uint256) {\n        return ts().assetReserves[_asset];\n    }\n\n    function totalReserves() public view returns (uint256) {\n        return ts().totalReserves;\n    }\n\n    function totalDebt() public view returns (uint256) {\n        return ts().totalDebt;\n    }\n\n    function permissionQueue(uint256 _index) public view returns (Queue memory) {\n        return qs().get(_index);\n    }\n\n    function lastPermissionQueueIndex() public view returns (uint256) {\n        return qs().currentIndex;\n    }\n\n    function timelockEnabled() public view returns (bool) {\n        return ts().timelockEnabled;\n    }\n\n    function useExcessReserves() public view returns (bool) {\n        return ts().useExcessReserves;\n    }\n\n    function onChainGovernanceTimelock() public view returns (uint256) {\n        return ts().onChainGovernanceTimelock;\n    }\n\n    function REQ() public view returns (IREQ) {\n        return ts().REQ;\n    }\n\n    function CREQ() public view returns (ICreditREQ) {\n        return ts().CREQ;\n    }\n}\n"
    },
    "contracts/oldFacets/v00/IAssetPricer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\ninterface IAssetPricer {\n  function valuation(address _asset, uint256 _amount)\n    external\n    view\n    returns (uint256);\n}\n"
    },
    "contracts/facets/TreasuryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../libraries/LibStorage.sol\";\nimport \"../utils/SafeERC20.sol\";\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/ICreditREQ.sol\";\nimport \"../interfaces/IAssetPricer.sol\";\nimport \"../interfaces/ITreasury.sol\";\n\n// the managing / status input is coded as follows:\n// enum STATUS {\n//     ASSETDEPOSITOR, = 0\n//     ASSET, = 1\n//     ASSETMANAGER, = 2\n//     REWARDMANAGER, = 3\n//     DEBTMANAGER, = 4\n//     DEBTOR, = 5\n//     COLLATERAL, = 6\n//     CREQ = 7\n// }\n\n// Local Queue struct outside of LibStorage to keep upgradeability\n// The managing field uses the indexing according to the commented enum above\n// We use uint256 as enums are not upgradeable.\nstruct Queue {\n    uint256 managing;\n    address toPermit;\n    address pricer;\n    uint256 timelockEnd;\n    bool nullify;\n    bool executed;\n    address quote;\n}\n\n// Helper library to enable upgradeable queuing\n// It just uses the current state of the queue storage and parses it to\n// the Queue struct above - which avoids using arrays or mappings of structs\n// Gas cost is not too important here as these are only used in rare cases\nlibrary QueueStorageLib {\n    function push(QueueStorage storage self, Queue memory newEntry) internal {\n        uint256 newIndex = self.currentIndex + 1;\n        self.currentIndex = newIndex;\n        self.managing[newIndex] = newEntry.managing;\n        self.toPermit[newIndex] = newEntry.toPermit;\n        self.pricer[newIndex] = newEntry.pricer;\n        self.quote[newIndex] = newEntry.quote;\n        self.timelockEnd[newIndex] = newEntry.timelockEnd;\n        self.nullify[newIndex] = newEntry.nullify;\n        self.executed[newIndex] = newEntry.executed;\n    }\n\n    function get(QueueStorage storage self, uint256 _index) internal view returns (Queue memory) {\n        require(_index <= self.currentIndex, \"Queue: Invalid index\");\n        return\n            Queue(\n                self.managing[_index],\n                self.toPermit[_index],\n                self.pricer[_index],\n                self.timelockEnd[_index],\n                self.nullify[_index],\n                self.executed[_index],\n                self.quote[_index]\n            );\n    }\n}\n\n// The treasury facet that contains the logic that changes the storage\n// Aligned with EIP-2535, the contract has no constructor or an own state\ncontract TreasuryFacet is ITreasury, WithStorage {\n    using SafeERC20 for IERC20;\n    using QueueStorageLib for QueueStorage;\n\n    /* ========== EVENTS ========== */\n    event Deposit(address indexed asset, uint256 amount, uint256 value);\n    event Withdrawal(address indexed asset, uint256 amount, uint256 value);\n    event CreateDebt(address indexed debtor, address indexed asset, uint256 amount, uint256 value);\n    event RepayDebt(address indexed debtor, address indexed asset, uint256 amount, uint256 value);\n    event Managed(address indexed asset, uint256 amount);\n    event ReservesAudited(uint256 indexed totalReserves);\n    event Minted(address indexed caller, address indexed recipient, uint256 amount);\n    event PermissionQueued(uint256 indexed status, address queued);\n    event Permissioned(address addr, uint256 indexed status, bool result);\n\n    // administrative\n    modifier onlyGovernor() {\n        LibStorage.enforceGovernor();\n        _;\n    }\n\n    modifier onlyPolicy() {\n        LibStorage.enforcePolicy();\n        _;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice allow approved address to deposit an asset for ts().REQ\n     * @param _amount uint256\n     * @param _asset address\n     * @param _profit uint256\n     * @return send_ uint256\n     */\n    function deposit(\n        uint256 _amount,\n        address _asset,\n        uint256 _profit\n    ) external override returns (uint256 send_) {\n        if (ts().permissions[1][_asset]) {\n            require(ts().permissions[0][msg.sender], \"Treasury: not approved\");\n        } else {\n            revert(\"Treasury: invalid asset\");\n        }\n\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 value = assetValue(_asset, _amount);\n        // mint needed and store amount of rewards for distribution\n        send_ = value - _profit;\n        ts().REQ.mint(msg.sender, send_);\n\n        ts().totalReserves += value;\n\n        emit Deposit(_asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to burn REQ for reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function withdraw(uint256 _amount, address _asset) external override {\n        require(ts().permissions[1][_asset], \"Treasury: not accepted\");\n        require(ts().permissions[2][msg.sender], \"Treasury: not approved\");\n\n        uint256 value = assetValue(_asset, _amount);\n        ts().REQ.burnFrom(msg.sender, value);\n\n        ts().totalReserves -= value;\n\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n\n        emit Withdrawal(_asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to withdraw assets\n     * @param _asset address\n     * @param _amount uint256\n     */\n    function manage(address _asset, uint256 _amount) external override {\n        require(ts().permissions[2][msg.sender], \"Treasury: not approved\");\n\n        if (ts().permissions[1][_asset]) {\n            uint256 value = assetValue(_asset, _amount);\n            if (ts().useExcessReserves) require(int256(value) <= excessReserves(), \"Treasury: insufficient reserves\");\n\n            ts().totalReserves -= value;\n        }\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n        emit Managed(_asset, _amount);\n    }\n\n    /**\n     * @notice mint new REQ using excess reserves\n     * @param _recipient address\n     * @param _amount uint256\n     */\n    function mint(address _recipient, uint256 _amount) external override {\n        require(ts().permissions[3][msg.sender], \"Treasury: not approved\");\n        if (ts().useExcessReserves) require(int256(_amount) <= excessReserves(), \"Treasury: insufficient reserves\");\n\n        ts().REQ.mint(_recipient, _amount);\n        emit Minted(msg.sender, _recipient, _amount);\n    }\n\n    /**\n     * DEBT: The debt functions allow approved addresses to borrow treasury assets\n     * or REQ from the treasury, using CREQ as collateral. This might allow an\n     * CREQ holder to provide REQ liquidity without taking on the opportunity cost\n     * of unstaking, or alter their backing without imposing risk onto the treasury.\n     * Many of these use cases are yet to be defined, but they appear promising.\n     * However, we urge the community to think critically and move slowly upon\n     * proposals to acquire these permissions.\n     */\n\n    /**\n     * @notice allow approved address to borrow reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function incurDebt(uint256 _amount, address _asset) external override {\n        uint256 value;\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n\n        if (_asset == address(ts().REQ)) {\n            value = _amount;\n        } else {\n            value = assetValue(_asset, _amount);\n        }\n        require(value != 0, \"Treasury: invalid asset\");\n\n        ts().CREQ.changeDebt(value, msg.sender, true);\n        require(ts().CREQ.debtBalances(msg.sender) <= ts().debtLimits[msg.sender], \"Treasury: exceeds limit\");\n        ts().totalDebt += value;\n\n        if (_asset == address(ts().REQ)) {\n            ts().REQ.mint(msg.sender, value);\n            ts().reqDebt += value;\n        } else {\n            ts().totalReserves -= value;\n            IERC20(_asset).safeTransfer(msg.sender, _amount);\n        }\n        emit CreateDebt(msg.sender, _asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with reserves\n     * @param _amount uint256\n     * @param _asset address\n     */\n    function repayDebtWithReserve(uint256 _amount, address _asset) external override {\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n        require(ts().permissions[1][_asset], \"Treasury: not accepted\");\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 value = assetValue(_asset, _amount);\n        ts().CREQ.changeDebt(value, msg.sender, false);\n        ts().totalDebt -= value;\n        ts().totalReserves += value;\n        emit RepayDebt(msg.sender, _asset, _amount, value);\n    }\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with REQ\n     * @param _amount uint256\n     */\n    function repayDebtWithREQ(uint256 _amount) external {\n        require(ts().permissions[5][msg.sender], \"Treasury: not approved\");\n        ts().REQ.burnFrom(msg.sender, _amount);\n        ts().CREQ.changeDebt(_amount, msg.sender, false);\n        ts().totalDebt -= _amount;\n        ts().reqDebt -= _amount;\n        emit RepayDebt(msg.sender, address(ts().REQ), _amount, _amount);\n    }\n\n    /* ========== MANAGERIAL FUNCTIONS ========== */\n\n    /**\n     * @notice takes inventory of all tracked assets\n     * @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external onlyGovernor {\n        uint256 reserves;\n        address[] memory assets = ts().registry[1];\n        for (uint256 i = 0; i < assets.length; i++) {\n            if (assets[i] != address(0) && ts().permissions[1][assets[i]]) {\n                reserves += slashedAssetValue(assets[i], IERC20(assets[i]).balanceOf(address(this)));\n            }\n        }\n        ts().totalReserves = reserves;\n        emit ReservesAudited(reserves);\n    }\n\n    /**\n     * @notice set max debt for address\n     * @param _address address\n     * @param _limit uint256\n     */\n    function setDebtLimit(address _address, uint256 _limit) external onlyGovernor {\n        ts().debtLimits[_address] = _limit;\n    }\n\n    /**\n     * @notice enable permission from queue\n     * @param _status STATUS\n     * @param _address address\n     * @param _pricer address\n     * @param _quote address\n     */\n    function enable(\n        uint256 _status,\n        address _address,\n        address _pricer,\n        address _quote\n    ) external {\n        require(!ts().timelockEnabled, \"Use queueTimelock\");\n        if (_status == 7) {\n            ts().CREQ = ICreditREQ(_address);\n        } else {\n            ts().permissions[_status][_address] = true;\n\n            if (_status == 1) {\n                ts().assetPricer[_address] = _pricer;\n                ts().quotes[_address] = _quote;\n            }\n\n            (bool registered, ) = indexInRegistry(_address, _status);\n            if (!registered) {\n                ts().registry[_status].push(_address);\n            }\n        }\n        emit Permissioned(_address, _status, true);\n    }\n\n    /**\n     *  @notice disable permission from address\n     *  @param _status STATUS\n     *  @param _toDisable address\n     */\n    function disable(uint256 _status, address _toDisable) external {\n        require(msg.sender == ms().governor || msg.sender == ms().guardian, \"Only governor or guardian\");\n        ts().permissions[_status][_toDisable] = false;\n        emit Permissioned(_toDisable, _status, false);\n    }\n\n    /**\n     * @notice check if ts().registry contains address\n     * @return (bool, uint256)\n     */\n    function indexInRegistry(address _address, uint256 _status) public view returns (bool, uint256) {\n        address[] memory entries = ts().registry[_status];\n        for (uint256 i = 0; i < entries.length; i++) {\n            if (_address == entries[i]) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @notice changes the use of excess reserves for minting\n     */\n    function setUseExcessReserves() external {\n        ts().useExcessReserves = !ts().useExcessReserves;\n    }\n\n    /* ========== TIMELOCKED FUNCTIONS ========== */\n\n    // functions are used prior to enabling on-chain governance\n\n    /**\n     * @notice queue address to receive permission\n     * @param _status STATUS\n     * @param _address address\n     * @param _pricer address\n     * @param _quote address\n     */\n    function queueTimelock(\n        uint256 _status,\n        address _address,\n        address _pricer,\n        address _quote\n    ) external onlyGovernor {\n        require(_address != address(0));\n        require(ts().timelockEnabled, \"Timelock is disabled, use enable\");\n        uint256 timelock = block.timestamp + ts().timeNeededForQueue;\n        if (_status == 2) {\n            timelock = block.timestamp + ts().timeNeededForQueue * 2;\n        }\n        if (_pricer != address(0)) {\n            require(_quote != address(0), \"Must provide quote\");\n        }\n\n        qs().push(\n            Queue({managing: _status, toPermit: _address, pricer: _pricer, timelockEnd: timelock, nullify: false, executed: false, quote: _quote})\n        );\n        emit PermissionQueued(_status, _address);\n    }\n\n    /**\n     *  @notice enable queued permission\n     *  @param _index uint256\n     */\n    function execute(uint256 _index) external {\n        require(ts().timelockEnabled == true, \"Timelock is disabled, use enable\");\n\n        Queue memory info = qs().get(_index);\n\n        require(!info.nullify, \"Action has been nullified\");\n        require(!info.executed, \"Action has already been executed\");\n        require(block.timestamp >= info.timelockEnd, \"Timelock not complete\");\n\n        if (info.managing == 7) {\n            ts().CREQ = ICreditREQ(info.toPermit);\n        } else {\n            ts().permissions[info.managing][info.toPermit] = true;\n\n            if (info.managing == 1) {\n                ts().assetPricer[info.toPermit] = info.pricer;\n                ts().quotes[info.toPermit] = info.quote;\n            }\n            (bool registered, ) = indexInRegistry(info.toPermit, info.managing);\n            if (!registered) {\n                ts().registry[info.managing].push(info.toPermit);\n            }\n        }\n        qs().executed[_index] = true;\n        emit Permissioned(info.toPermit, info.managing, true);\n    }\n\n    /**\n     * @notice cancel timelocked action\n     * @param _index uint256\n     */\n    function nullify(uint256 _index) external onlyGovernor {\n        qs().nullify[_index] = true;\n    }\n\n    /**\n     * @notice disables timelocked functions\n     */\n    function disableTimelock() external onlyGovernor {\n        require(ts().timelockEnabled, \"timelock already disabled\");\n        if (ts().onChainGovernanceTimelock != 0 && ts().onChainGovernanceTimelock <= block.timestamp) {\n            ts().timelockEnabled = false;\n        } else {\n            ts().onChainGovernanceTimelock = block.timestamp + ts().timeNeededForQueue * 7; // 7-day timelock\n        }\n    }\n\n    /**\n     * @notice enables timelocks after initilization\n     */\n    function enableTimelock(uint256 _timeNeededForQueue) external onlyGovernor {\n        require(!ts().timelockEnabled, \"timelock already enabled\");\n        ts().timelockEnabled = true;\n        ts().timeNeededForQueue = _timeNeededForQueue;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice returns excess reserves not backing assets\n     * @return int\n     */\n    function excessReserves() public view returns (int256) {\n        return int256(ts().totalReserves) - int256(ts().REQ.totalSupply() - ts().totalDebt);\n    }\n\n    /**\n     * @notice returns external REQ valuation of asset\n     * @param _asset address\n     * @param _amount uint256\n     * @return value_ uint256\n     */\n    function assetValue(address _asset, uint256 _amount) public view override returns (uint256 value_) {\n        if (ts().permissions[1][_asset]) {\n            value_ = IAssetPricer(ts().assetPricer[_asset]).valuation(_asset, ts().quotes[_asset], _amount);\n        } else {\n            revert(\"Treasury: invalid asset\");\n        }\n    }\n\n    /**\n     * @notice returns internal REQ valuation of asset\n     * @param _asset address\n     * @param _amount uint256\n     * @return value_ uint256\n     */\n    function slashedAssetValue(address _asset, uint256 _amount) public view returns (uint256 value_) {\n        if (ts().permissions[1][_asset]) {\n            value_ = IAssetPricer(ts().assetPricer[_asset]).slashedValuation(_asset, ts().quotes[_asset], _amount);\n        } else {\n            revert(\"Treasury: invalid asset\");\n        }\n    }\n\n    /**\n     * @notice returns supply metric that cannot be manipulated by debt\n     * @dev use this any time you need to query supply\n     * @return uint256\n     */\n    function baseSupply() external view override returns (uint256) {\n        return ts().REQ.totalSupply() - ts().reqDebt;\n    }\n\n    // VIEWS FROM STORAGE\n\n    function assetPricer(address _entry) external view returns (address) {\n        return ts().assetPricer[_entry];\n    }\n\n    function registry(uint256 _status, uint256 _entry) external view returns (address) {\n        return ts().registry[_status][_entry];\n    }\n\n    function permissions(uint256 _status, address _entry) external view returns (bool) {\n        return ts().permissions[_status][_entry];\n    }\n\n    function debtLimits(address _asset) public view returns (uint256) {\n        return ts().debtLimits[_asset];\n    }\n\n    function assetReserves(address _asset) public view returns (uint256) {\n        return ts().assetReserves[_asset];\n    }\n\n    function totalReserves() public view returns (uint256) {\n        return ts().totalReserves;\n    }\n\n    function totalDebt() public view returns (uint256) {\n        return ts().totalDebt;\n    }\n\n    function permissionQueue(uint256 _index) public view returns (Queue memory) {\n        return qs().get(_index);\n    }\n\n    function lastPermissionQueueIndex() public view returns (uint256) {\n        return qs().currentIndex;\n    }\n\n    function timelockEnabled() public view returns (bool) {\n        return ts().timelockEnabled;\n    }\n\n    function useExcessReserves() public view returns (bool) {\n        return ts().useExcessReserves;\n    }\n\n    function onChainGovernanceTimelock() public view returns (uint256) {\n        return ts().onChainGovernanceTimelock;\n    }\n\n    function REQ() public view returns (IREQ) {\n        return ts().REQ;\n    }\n\n    function CREQ() public view returns (ICreditREQ) {\n        return ts().CREQ;\n    }\n}\n"
    },
    "contracts/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {\n        // adding ERC165 data\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // add your own state variables \n        // EIP-2535 specifies that the `diamondCut` function takes two optional \n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \n    }\n\n\n}\n"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions.\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory facetFunctionSelectors_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/test/MockREQ.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/IREQ.sol\";\n\ncontract MockREQ is ERC20, IREQ {\n    constructor() ERC20(\"Requiem\", \"REQ\", 18) {}\n\n    function mint(address to, uint256 value) external override {\n        _mint(to, value);\n    }\n\n    function burn(uint256 value) external override {\n        _burn(_msgSender(), value);\n    }\n\n    function burnFrom(address account, uint256 amount) external override {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/test/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./Context.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is IERC20, Context {\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/test/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/facets/ManagementFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IManagement.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {WithStorage} from \"../libraries/LibStorage.sol\";\nimport {AccessControlled} from \"../types/AccessControlled.sol\";\n\ncontract ManagementFacet is IManagement, AccessControlled, WithStorage {\n    /* ========== GOV ONLY ========== */\n\n    function pushGovernor(address _newGovernor, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) ms().governor = _newGovernor;\n        ms().newGovernor = _newGovernor;\n        emit GovernorPushed(ms().governor, ms().newGovernor, _effectiveImmediately);\n    }\n\n    function pushGuardian(address _newGuardian, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) ms().guardian = _newGuardian;\n        ms().newGuardian = _newGuardian;\n        emit GuardianPushed(ms().guardian, ms().newGuardian, _effectiveImmediately);\n    }\n\n    function pushPolicy(address _newPolicy, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) ms().policy = _newPolicy;\n        ms().newPolicy = _newPolicy;\n        emit PolicyPushed(ms().policy, ms().newPolicy, _effectiveImmediately);\n    }\n\n    function pushVault(address _newVault, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) ms().vault = _newVault;\n        ms().newVault = _newVault;\n        emit VaultPushed(ms().vault, ms().newVault, _effectiveImmediately);\n    }\n\n    /* ========== PENDING ROLE ONLY ========== */\n\n    function pullGovernor() external {\n        require(msg.sender == ms().newGovernor, \"!newGovernor\");\n        emit GovernorPulled(ms().governor, ms().newGovernor);\n        ms().governor = ms().newGovernor;\n    }\n\n    function pullGuardian() external {\n        require(msg.sender == ms().newGuardian, \"!newGuard\");\n        emit GuardianPulled(ms().guardian, ms().newGuardian);\n        ms().guardian = ms().newGuardian;\n    }\n\n    function pullPolicy() external {\n        require(msg.sender == ms().newPolicy, \"!newPolicy\");\n        emit PolicyPulled(ms().policy, ms().newPolicy);\n        ms().policy = ms().newPolicy;\n    }\n\n    function pullVault() external {\n        require(msg.sender == ms().newVault, \"!newVault\");\n        emit VaultPulled(ms().vault, ms().newVault);\n        ms().vault = ms().newVault;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function governor() external view returns (address) {\n        return ms().governor;\n    }\n\n    function guardian() external view returns (address) {\n        return ms().guardian;\n    }\n\n    function policy() external view returns (address) {\n        return ms().policy;\n    }\n\n    function vault() external view returns (address) {\n        return ms().vault;\n    }\n}\n"
    },
    "contracts/types/AccessControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IManagement.sol\";\n\nabstract contract AccessControlled {\n  /* ========== EVENTS ========== */\n\n  event ManagementUpdated(IManagement indexed management);\n\n  string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n  /* ========== STATE VARIABLES ========== */\n\n  IManagement public management;\n\n  /* ========== Constructor ========== */\n\n  function intitalizeManagement(IManagement _management) internal {\n    management = _management;\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier onlyGovernor() {\n    require(msg.sender == management.governor(), UNAUTHORIZED);\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == management.guardian(), UNAUTHORIZED);\n    _;\n  }\n\n  modifier onlyPolicy() {\n    require(msg.sender == management.policy(), UNAUTHORIZED);\n    _;\n  }\n\n  modifier onlyVault() {\n    require(msg.sender == management.vault(), UNAUTHORIZED);\n    _;\n  }\n\n  /* ========== GOV ONLY ========== */\n\n  function setManagement(IManagement _newManagement) external onlyGovernor {\n    management = _newManagement;\n    emit ManagementUpdated(_newManagement);\n  }\n}\n"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}